% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/1-Simulation.R
\name{BFDA.sim}
\alias{BFDA.sim}
\title{Create a BFDA object
Conduct simulations for a BFDA}
\usage{
BFDA.sim(
  expected.ES,
  type = c("t.between", "t.paired", "correlation", "abtest"),
  prior = NULL,
  n.min = 10,
  n.max = 500,
  design = c("sequential", "fixed.n"),
  boundary = Inf,
  B = 1000,
  stepsize = NA,
  alternative = c("two.sided", "greater", "less"),
  verbose = TRUE,
  cores = 1,
  ETA = FALSE,
  options.sample = list(),
  seed = 1234,
  ...
)
}
\arguments{
\item{expected.ES}{The assumed true effect size. This can be a single number (this leads to a fixed assumed effect size, as in a classical power analysis) or a vector of numbers (e.g., \code{rnorm(100000, 0.5, 0.1)}). If it is a vector, the sampler draws a new effect size from this vector at each step. In this case, the provided distribution represents the uncertainty about the true effect size.}

\item{type}{Currently four designs are implemented: c("t.between", "t.paired", "correlation", "abtest")}

\item{prior}{Define the prior distribution of your alternative hypothesis. Argument takes a list as an input: The first element of the list should be a character string defining the type of the distribution (e.g., "t", "Cauchy", or "normal" for t-tests). The second element of the list is another list containing the parameters of the distribution. For example: \code{prior = list("Cauchy", list(prior.location = 0, prior.scale = 1))}. For available distributions, see the BFDA manual \code{vignette("BFDA_manual", package = "BFDA")}. If prior is NA, default values are applied.}

\item{n.min}{Minimum n before optional stopping is started}

\item{n.max}{Maximum n - if that is reached without hitting a boundary, the run is aborted}

\item{design}{"fixed.n" or "sequential". If design=="fixed.n", \code{n.min} and \code{boundary} are irrelevant, and all samples are drawn with n=n.max.}

\item{boundary}{The Bayes factor where a sequential run is stopped. For a fixed-n design, \code{boundary} is automatically set to Inf. Provide either two values for lower and upper boundary (e.g., c(1/3, 6). If only one value is provided, it automatically uses its reciprocal for the other boundary.}

\item{B}{Number of bootstrap samples; should be dividable by the numbers of \code{cores} (see also \code{getDoParWorkers()})}

\item{stepsize}{The number of observations added to the sample in each step of a sequential process. If NA, the sample is increased +1 until it's 100, and +10 from that size on.}

\item{alternative}{One of c("two.sided", "greater", "less") for one-sided or two-sided hypothesis tests in data analysis. Hence, this refers to the directionality of the analysis prior}

\item{verbose}{Show output about progress?}

\item{cores}{number of parallel processes. If cores==1, no parallel framework is used.}

\item{ETA}{Compute an estimate of the full simulation time? This adds some overhead to the simulation, so turn off for actual simulations. NOT IMPLEMENTED YET}

\item{options.sample}{Further parameters passed to the data generating function (depending on the \code{type} of design). Currently only used for AB-test: list(effecttype=...) with possible parameters \code{"OR"} (odds ratio), \code{"logOR"} (log odds ratio), \code{RR} (relative risk), \code{AR} (absolute risk); defines the type of effect size used as input in the \code{expected.ES} argument.}

\item{seed}{The seed that is passed to the \code{dorng} function (which ensures reproducibility with parallel processing). If this parameter is set to \code{NULL}, a new seed is chosen at each run.}

\item{...}{Further parameters passed to the BF.test function.}
}
\description{
Create a BFDA object
Conduct simulations for a BFDA
}
\examples{
\dontrun{
sim <- BFDA.sim(expected.ES=0.5, type="t.between", 
					prior=list("Cauchy", list(prior.location=0, prior.scale=1)),
         n.min=20, n.max=300, boundary=Inf, stepsize=1, design="sequential", 
				B=1000, verbose=TRUE, cores=2)
save(sim, file="sim0.5.RData")
BFDA.analyze(sim)
BFDA.analyze(sim, boundary=6)
plot(sim, boundary=6)
plot(sim, boundary=6, n.max=80)
}
}
